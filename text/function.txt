函数笔记 


注意: 函数体内部的语句在执行时 , 一旦执行到return , 函数就执行完毕 , 将结果返回 
如没有return 函数执行完毕后返回undefined;
-----定义-和调用-------------------------------------------------------------------------------------
1  function fn(){}

2  var fn = function(){}  //匿名函数


----传参-----------
传入的参数比定义的参数多没问题,
少也没问题   函数形参将受到undefined;  要避免收到undefined 可以对参数检查 return 出去

-----arguments----

**只在函数内部起作用  永远指向调用传入的实参   类似数组 但它不是数组

函数不定义形参也可以获取到实参


-------rest----------
Es6引入了   rest  参数

function fn(a,b,...rest){
    rest  代表除a,b外剩下的实参

-------return-------

javascript  引擎有一个在行末尾自动添加分号的机制,  返回undefined;

	function aa(){
		return 
			{ bb:11 }
	}





-------------变量作用域-----------------------------------------------------------------------------
用var申明的变量是有作用域的  ;

在函数体内申明的变量 , 该变量的作用域是整个函数体, 在函数体外不可引用该变量;

不同的函数各自申明了同一个变量 , 该变量只在各自的函数体内气作用 , 互不影响;

嵌套的函数 , 内部函数可以访问外部函数定义的变量 , 反过来不行;

嵌套的函数 对于重名的变量  内部函数 var 申明的  外部函数只在自己的函数体内查找
				    var未申明的         变量被改变 
-----------------------
变量提升:

javascript函数定义有个特点,他会先扫描整个函数体的语句 , 把所有申明的变量'提升'到函数顶部
javascript引擎自动提升了变量的申明 , 但不提升变量的赋值;

-----------------------
全局作用域:
不在函数体内定义的变量就具有全局作用域 , 默认有个全局对象window ,全局作用域的变量实际上是被绑定到window的一个属性;直接访问变量和访问window.变量是一样的



---------------------
命名空间
不同的js文件使用了相同的全局变量 , 或定义了相同名字的顶层函数 , 都会造成命名冲突

减少冲突的方法:  把自己的所有变量和函数全部绑定到一个全局变量中

-----------------------
局部作用域(实际上是函数内部) 

在语句块中是无法定义具有局部作用域的变量 , 为了解决块级作用域 , es6新的关键字let 可以代替var申明一个快级作用域的变量;

const定义常量  , 具有快级作用域;


----------------------方法-----------------------------------------------------------------------------

绑定到对象上的函数称为方法 
在一个方法内部 , this是一个特殊变量 , 它始终指向当前对象

以对象的方法形式调用 , this 指向被调用的对象

单独调用 函数 , this指向window;

在strict模式下  让函数的this指向undefined;   这只是让错误露出来 没有解决this指向的问题

apply() 和  call()  可改变this的指向  
第一个参数是this指向的变量  第二个参数apply是数组的形式传入   call是按顺序传入



---------------------高阶函数--------------------------------------------------------------------------

高阶函数就是让函数的参数能够接收别的函数

-------------------------------------


map ; 数组的方法  参数为一个函数   返回新的数组

reduce : 数组的方法   必须接收两个参数  把结果和下一个元素做累积计算

filter  把传入的函数依次作用于每个元素 , 根据返回值是rrue(保留)还是false(丢弃)决定是保留还是丢弃元素
	
	函数中可以有多个参数  arr.filter(function(ele,index,array){}


sort    不管是冒泡排序还是快速排序核心是比较两个元素的大小

	sort是根据字符的ASCII码在排序  2 的码比2的小  所以22在3的前面
	sort拍数字时,默认把数字转为string  

 	可以接收一个比较函数来实现自定义的排序
-----------
对数字的排序

   正序
	arr.sort(function(x,y){
		if(x>y){ return 1};
		if(x<y) return -1;
		return 0;
	}

   倒序 x>y return -1 ....

-----------
对字符串的排序
    默认大写的在前面,


---------------------------闭包-------------------------------------------------------------------

闭包就是携带状态的函数 , 并且它的状态可以完全对外隐藏起来 ;

--------------------------箭头函数------------------------------------------------------------------

x => x * x  相当于  function (x) {
    			return x * x;
		    }

-----------------------generator-------------------------------------------------------------------
es6引入的新的数据类型
看上去像一个函数 , 可以返回多次

函数遇到return才返回,没有return则默认返回undefined;

generator 由 function*定义(多出一个****) 且除了return 还可以用yield返回多次

可以记录状态

调用  : 函数名().next()    for ... of 



























